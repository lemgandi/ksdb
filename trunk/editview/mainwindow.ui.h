/****************************************************************************
** ui.h extension file, included from the uic-generated form implementation.
**
** If you want to add, delete, or rename functions or slots, use
** Qt Designer to update this file, preserving your code.
**
** You should not define a constructor or destructor in this file.
** Instead, write your code in functions called init() and destroy().
** These will automatically be called by the form's constructor and
** destructor.
*****************************************************************************/
const char *dbiEntry = "databaseInterface";
const char *tableEntry="tableName";
const char *dbNEntry="databaseName";

//
// Initialize myself. Make sure that inputdata handlers take
// ownership of the pointers we will put into them.
//
void mainwindow::init()
{
   myDatabaseInterface=0;
   sForm=new settingsForm(this,"SettingsForm",TRUE);
   connect(sForm,SIGNAL(newDBParams(const QString &, const QString &, const QString &)),this,SLOT(dbiParams(const QString &, const QString &, const QString &)));
   
    inputDataHandlers.setAutoDelete(TRUE);
}

//
// At exit, delete dbi
//
void mainwindow::destroy()
{
    delete myDatabaseInterface;
    
}
//
// Show the widgets we have read out of our file on the screen 
// by making them children of the groupbox.
//
void mainwindow::setupWidgets()
{
    widgetData::iterator iter;
    QWidget *wP;
    
    for(iter=wData.begin();iter != wData.end(); ++iter)
    {
	wP=iter.key();
	wP->reparent(WGroupBox,wP->pos(),TRUE);
    }
}

//
// Handle fileOpen signal.
//
void mainwindow::fileOpen()
{
   widgetHandlerDictionary wHandlers;

   wHandlers.insert("defailt",new widgetHandler());
   wHandlers.insert("QLabel", new wLabelHandler());
   wHandlers.insert("QLineEdit", new wInputLineEditMaker(this,&inputDataHandlers));
   wHandlers.insert("QTextEdit", new wInputTextEditMaker(this,&inputDataHandlers));
   wHandlers.insert("QCheckBox",new wInputCheckBoxMaker(this,&inputDataHandlers));
   wHandlers.insert("QPushButton",new wInputButtonMaker(this,&inputDataHandlers));
   wHandlers.setAutoDelete(TRUE);
   currentFN=getOpenFileName();
   
   if(! currentFN.isNull())
   {
      inputDataHandlers.clear();
      ksdbFileReader myReader(currentFN,wHandlers);
      if(myReader.readFile())
      {	 
	 QSize sizeDiff=size() -WGroupBox->size();	   
	 QSize boxSize=myReader.getStartScreenSize();
	 resize(boxSize+sizeDiff);
	 WGroupBox->resize(boxSize);
	 
	 QPixmap myBG = myReader.getBGPixMap();
	 if(! myBG.isNull())
	    WGroupBox->setPaletteBackgroundPixmap(myBG);
	 wData=myReader.getData();
	 setupWidgets();
	 setupDBI();
      }
      else
      {
	 QMessageBox::critical(this,"Bad File",
         QString("File %1 is not valid.\nError: %2")
	.arg(currentFN).arg(myReader.errorString()));
      }
   }
   wHandlers.clear(); // Deletes all the new s above.
}

//
// Get name of model file to open (generated by modelmaker)
//
QString mainwindow::getOpenFileName()
{
    QString retVal=QFileDialog::getOpenFileName(".",
	"*.ksdb *.xml;;",
	this,
	"Open Model File",
	"Choose a Model File");
    if(! retVal.isNull())
    {
	QSettings mySettings;
	mySettings.setPath("tomshiro.org","ksdb",
			   QSettings::User);
	mySettings.beginGroup(QString("/"+retVal));
	currentDBI=mySettings.readEntry(dbiEntry);
	currentTableName=mySettings.readEntry(tableEntry);
	currentDBName=mySettings.readEntry(dbNEntry);
	if( currentDBI.isNull() ) 
	{	   	
	    sForm->exec();
	    if(! currentDBI.isNull())	    
		mySettings.writeEntry(dbiEntry,currentDBI);
		mySettings.writeEntry(tableEntry,currentTableName);
		mySettings.writeEntry(dbNEntry,currentDBName);
	}	

    }
    if(currentDBI.isNull())
	retVal=(const char *)0;
    qDebug(
	    "currentTableName: %s currentDBI: %s currentDBName: %s",
	    (const char *)currentTableName,
	    (const char *)currentDBI, 
	    (const char *)currentDBName);   
    return retVal;   
}


//
// check Dirty flag and exit application.
//
void mainwindow::fileExit()
{
   if(screenIsDirty())
      dumpCurrentInputData();

    inputDataHandlers.clear(); // Delete new ed inputhandlers.
    QApplication::exit(0);
}


void mainwindow::editUndo()
{

}


void mainwindow::editRedo()
{

}


void mainwindow::editCut()
{

}


void mainwindow::editCopy()
{

}


void mainwindow::editPaste()
{

}


void mainwindow::editFind()
{

}


void mainwindow::helpIndex()
{

}


void mainwindow::helpContents()
{

}


void mainwindow::helpAbout()
{

}

//
// Dump current contents of screen.
//
void mainwindow::dumpCurrentInputData()
{
    inputHandlerIterator iter(inputDataHandlers);
    wInputHandler *wh;
    qDebug("Dumping current input data. inputDataHandlers contains %d members",
	   inputDataHandlers.count());
    while( 0 != (wh = iter.current()))
    {
	if(! wh->isA("wButtonInputHandler"))
	    qDebug("Current contents of widget %p: %s",wh->getWidget(),(const char *)wh->getWidgetData());
	++iter;
    }
}


void mainwindow::Prev()
{
   qDebug("Prev");
   screenToDatabase();
   bool status;
   myDatabaseInterface->getPrevRecord(currentData,&status);
   if(!status)
   {
      currentData.clear();
      clearScreen();      
   }
   else
      dbFmtToScreen(currentData);

}

//
// Respond to "next" button.
//
void mainwindow::Next()
{
   qDebug("Next");
   screenToDatabase();
   bool success=TRUE;
   myDatabaseInterface->getNextRecord(currentData,&success);
   if(!success)
   {
      clearScreen();
      currentData.clear();
   }
   else
      dbFmtToScreen(currentData);    
}


void mainwindow::Search()
{
   qDebug("Search");

   currentData.clear();
   screenToDBFmt(currentData,FALSE);
   bool status;
   myDatabaseInterface->getRecord(currentData,&status);
   if(status)
      dbFmtToScreen(currentData);
   else
      clearScreen();

   qDebug("currentData[\"ID\"]=%s",(const char *)currentData["ID"]);
}


void mainwindow::First()
{   
   qDebug("First");
   screenToDatabase();
   myDatabaseInterface->getFirstRecord(currentData);
   dbFmtToScreen(currentData);
}


void mainwindow::Last()
{
   qDebug("Last");
   screenToDatabase();
   myDatabaseInterface->getLastRecord(currentData);
   dbFmtToScreen(currentData);
}

// 
// Quit button
// TODO: Provide really message if data is on screen.
//
void mainwindow::Quit()
{
   qDebug("Quit");  
   fileExit();
}

void mainwindow::dbiParams( const QString &tn, const QString &dn, const QString &ifn )
{
    currentTableName=tn;
    currentDBName=dn;
    currentDBI=ifn;
}
// 
// Set up database interface.
//
void mainwindow::setupDBI()
{
    colValues tableInfo;
    fieldVals theVals;
    widgetData::ConstIterator iter;

    for(iter=wData.constBegin(); iter != wData.constEnd(); ++iter)
    {
       theVals=iter.data();
       if( (theVals.contains("datatype")) && (theVals.contains("fieldname")) )
	  tableInfo[theVals["fieldname"]] = theVals["datatype"];
    }       
    myDatabaseInterface = new dataInterface(currentDBI,currentDBName);
    myDatabaseInterface->openDB();
    myDatabaseInterface->makeSetTable(currentTableName,tableInfo);
}

//
// Have fields on screen been edited?
//
bool mainwindow::screenIsDirty()
{
   bool retVal=FALSE;
   inputHandlerIterator iter(inputDataHandlers);
   wInputHandler *thisHandler;
   while(0 != (thisHandler =  iter.current()) )
   {
      retVal=thisHandler->hasData();
      if(retVal)
	 break;
      ++iter;
   }
   qDebug("screenIsDirty: retVal=%d",retVal);
   return retVal;
}

void mainwindow::dbFmtToScreen(const colValues &dbData)
{
   inputHandlerIterator iter(inputDataHandlers);
   wInputHandler *thisHandler;
   fieldVals widgetValues;
   while(0 != (thisHandler = iter.current()) )
   {
      QWidget *wMetaDataKey=thisHandler->getWidget();
      widgetValues=wData[wMetaDataKey];
      QString dataKey;
      if(widgetValues.contains("fieldname") )
      {
	  dataKey=widgetValues["fieldname"];
	  thisHandler->setWidgetData(dbData[dataKey]);
      }
      ++iter;
  }
 
}

//
// Dump values going to or coming from the database.
//
void mainwindow::dumpDBValues(const colValues & dv)
{
   colValues::ConstIterator iter;
   for(iter=dv.constBegin();iter != dv.constEnd();++iter)
      qDebug("Field %s value %s",(const char *)iter.key(),
	     (const char *)iter.data());

}

//
// If screen is dirty, write its contents to db.
// Called when we do prev(),next(), or first().
// NOT called for a search.
void mainwindow::screenToDatabase()
{
    if(screenIsDirty())
    {

	if(currentData.contains("ID") )	
	{
	   screenToDBFmt(currentData,FALSE);
	   myDatabaseInterface->updateRecord(currentData);
	}
	else
	{
	   screenToDBFmt(currentData,TRUE);
	   myDatabaseInterface->appendRecord(currentData);
	}
    }
}

//
// Pull data off screen and put into database input structure.
//
void mainwindow::screenToDBFmt( colValues &outVals,bool allVals )
{
   inputHandlerIterator iter(inputDataHandlers);
   wInputHandler *thisHandler;
   fieldVals widgetValues;
   while(0 != (thisHandler = iter.current()) )
   {
      QWidget *wMetaDataKey=thisHandler->getWidget();
      widgetValues=wData[wMetaDataKey];
      if (widgetValues.contains("fieldname"))      
      {
	 if(allVals)
	      outVals[widgetValues["fieldname"]] = 
		  thisHandler->getWidgetData();
	 if(thisHandler->hasData())
	      outVals[widgetValues["fieldname"]] = 
		  thisHandler->getWidgetData();

      }
      ++iter;
  }
}

//
// Clear the Screen!
//
void mainwindow::clearScreen()
{
   inputHandlerIterator iter(inputDataHandlers);
   wInputHandler *thisHandler;
   while(0 != (thisHandler = iter.current()) )
   {
      thisHandler->clear();
      ++iter;
   }
}
